//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : Parser.sm
//

#ifndef PARSER_SM_H
#define PARSER_SM_H


#define SMC_USES_IOSTREAMS

#include "statemap.h"

// Forward declarations.
class StateMap;
class StateMap_unexpected;
class StateMap_start;
class StateMap_word_state;
class StateMap_double_dot_state;
class StateMap_eq_state;
class StateMap_number_state;
class StateMap_oper_state;
class StateMap_white_space_state;
class StateMap_Default;
class ParserState;
class ParserContext;
class Parser;

class ParserState :
    public statemap::State
{
public:

    ParserState(const char * const name, const int stateId)
    : statemap::State(name, stateId)
    {};

    virtual void Entry(ParserContext&) {};
    virtual void Exit(ParserContext&) {};

    virtual void next(ParserContext& context);

protected:

    virtual void Default(ParserContext& context);
};

class StateMap
{
public:

    static StateMap_unexpected unexpected;
    static StateMap_start start;
    static StateMap_word_state word_state;
    static StateMap_double_dot_state double_dot_state;
    static StateMap_eq_state eq_state;
    static StateMap_number_state number_state;
    static StateMap_oper_state oper_state;
    static StateMap_white_space_state white_space_state;
};

class StateMap_Default :
    public ParserState
{
public:

    StateMap_Default(const char * const name, const int stateId)
    : ParserState(name, stateId)
    {};

    virtual void next(ParserContext& context);
};

class StateMap_unexpected :
    public StateMap_Default
{
public:
    StateMap_unexpected(const char * const name, const int stateId)
    : StateMap_Default(name, stateId)
    {};

    virtual void next(ParserContext& context);
};

class StateMap_start :
    public StateMap_Default
{
public:
    StateMap_start(const char * const name, const int stateId)
    : StateMap_Default(name, stateId)
    {};

    virtual void next(ParserContext& context);
};

class StateMap_word_state :
    public StateMap_Default
{
public:
    StateMap_word_state(const char * const name, const int stateId)
    : StateMap_Default(name, stateId)
    {};

    virtual void next(ParserContext& context);
};

class StateMap_double_dot_state :
    public StateMap_Default
{
public:
    StateMap_double_dot_state(const char * const name, const int stateId)
    : StateMap_Default(name, stateId)
    {};

    virtual void next(ParserContext& context);
};

class StateMap_eq_state :
    public StateMap_Default
{
public:
    StateMap_eq_state(const char * const name, const int stateId)
    : StateMap_Default(name, stateId)
    {};

    virtual void next(ParserContext& context);
};

class StateMap_number_state :
    public StateMap_Default
{
public:
    StateMap_number_state(const char * const name, const int stateId)
    : StateMap_Default(name, stateId)
    {};

    virtual void next(ParserContext& context);
};

class StateMap_oper_state :
    public StateMap_Default
{
public:
    StateMap_oper_state(const char * const name, const int stateId)
    : StateMap_Default(name, stateId)
    {};

    virtual void next(ParserContext& context);
};

class StateMap_white_space_state :
    public StateMap_Default
{
public:
    StateMap_white_space_state(const char * const name, const int stateId)
    : StateMap_Default(name, stateId)
    {};

    virtual void next(ParserContext& context);
};

class ParserContext :
    public statemap::FSMContext
{
public:

    explicit ParserContext(Parser& owner)
    : FSMContext(StateMap::start),
      _owner(owner)
    {};

    ParserContext(Parser& owner, const statemap::State& state)
    : FSMContext(state),
      _owner(owner)
    {};

    virtual void enterStartState()
    {
        getState().Entry(*this);
        return;
    }

    inline Parser& getOwner()
    {
        return (_owner);
    };

    inline ParserState& getState()
    {
        if (_state == NULL)
        {
            throw statemap::StateUndefinedException();
        }

        return dynamic_cast<ParserState&>(*_state);
    };

    inline void next()
    {
        getState().next(*this);
    };

private:
    Parser& _owner;
};


#endif // PARSER_SM_H

//
// Local variables:
//  buffer-read-only: t
// End:
//
